use p3_field::AbstractField;
use p3_field::{Field, TwoAdicField};
use p3_util::log2_strict_usize;

pub fn eval_poly<AF: AbstractField>(poly: &[AF], x: AF) -> AF {
    let mut acc = AF::zero();
    for coeff in poly.iter().rev() {
        acc *= x.clone();
        acc += coeff.clone();
    }
    acc
}

/// Calculates the k-adicity of n, i.e., the number of trailing 0s in a base-k
/// representation.
pub fn k_adicity(k: u64, mut n: u64) -> u32 {
    let mut r = 0;
    while n > 1 {
        if n % k == 0 {
            r += 1;
            n /= k;
        } else {
            return r;
        }
    }
    r
}

/// Returns the root of unity of order n, if one exists.
/// If no small multiplicative subgroup is defined, this is the 2-adic root
/// of unity of order n (for n a power of 2).
/// If a small multiplicative subgroup is defined, this is the root of unity
/// of order n for the larger subgroup generated by
/// `FftConfig::LARGE_SUBGROUP_ROOT_OF_UNITY`
/// (for n = 2^i * FftConfig::SMALL_SUBGROUP_BASE^j for some i, j).
pub fn get_root_of_unity<F: TwoAdicField>(n: u64) -> Option<F> {
    let mut omega: F;
    // if let Some(large_subgroup_root_of_unity) = F::LARGE_SUBGROUP_ROOT_OF_UNITY {
    //     let q = F::SMALL_SUBGROUP_BASE.expect(
    //         "LARGE_SUBGROUP_ROOT_OF_UNITY should only be set in conjunction with SMALL_SUBGROUP_BASE",
    //     ) as u64;
    //     let small_subgroup_base_adicity = F::SMALL_SUBGROUP_BASE_ADICITY.expect(
    //         "LARGE_SUBGROUP_ROOT_OF_UNITY should only be set in conjunction with SMALL_SUBGROUP_BASE_ADICITY",
    //     );

    //     let q_adicity = k_adicity(q, n);
    //     let q_part = q.checked_pow(q_adicity)?;

    //     let two_adicity = k_adicity(2, n);
    //     let two_part = 2u64.checked_pow(two_adicity)?;

    //     if n != two_part * q_part
    //         || (two_adicity > F::TWO_ADICITY as u32)
    //         || (q_adicity > small_subgroup_base_adicity)
    //     {
    //         return None;
    //     }

    //     omega = large_subgroup_root_of_unity;
    //     for _ in q_adicity..small_subgroup_base_adicity {
    //         omega = omega.exp_u64(q as u64);
    //     }

    //     for _ in two_adicity..(F::TWO_ADICITY as u32) {
    //         omega.square_in_place();
    //     }
    // } else {


// Compute the next power of 2.
let size = n.next_power_of_two() as u64;
// let log_size_of_group = ark_std::log2(usize::try_from(size).expect("too large"));
let log_size_of_group = log2_strict_usize(size as usize);

if n != size || log_size_of_group > F::TWO_ADICITY {
    return None;
}

// Compute the generator for the multiplicative subgroup.
// It should be 2^(log_size_of_group) root of unity.
// omega = F::TWO_ADIC_ROOT_OF_UNITY;
omega = F::two_adic_generator(n as usize);
for _ in log_size_of_group..F::TWO_ADICITY {
    // omega.square_in_place();
    omega = omega.square();
}


    // }
    Some(omega)
}